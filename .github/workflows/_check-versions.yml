# =============================================================================
# Reusable Workflow: Check Versions and Generate Build Matrix
# =============================================================================
# Checks for new vLLM releases and generates a unified build matrix.
# Called by the main build-wheel.yml workflow.
#
# Outputs a single build_matrix JSON that can be used with fromJSON() to
# spawn parallel build jobs for all variant/platform/version combinations.
#
# Usage:
#   jobs:
#     check-versions:
#       uses: ./.github/workflows/_check-versions.yml
#       with:
#         vllm_versions: "0.12.0"
#         build_noavx512: true
#         build_avx512: true
#       secrets: inherit
# =============================================================================

name: Check Versions (Reusable)

on:
  workflow_call:
    inputs:
      vllm_versions:
        description: 'vLLM versions (e.g., 0.12.0 or 0.11.2,0.12.0 or 0.11.0-0.12.0) - leave empty for auto-detect'
        required: false
        type: string
        default: ''
      build_noavx512:
        description: 'Build noavx512 (universal, AMD64+ARM64)'
        required: false
        type: boolean
        default: true
      build_avx512:
        description: 'Build avx512 (AMD64 only)'
        required: false
        type: boolean
        default: true
      build_avx512vnni:
        description: 'Build avx512vnni (AMD64 only)'
        required: false
        type: boolean
        default: true
      build_avx512bf16:
        description: 'Build avx512bf16 (AMD64 only)'
        required: false
        type: boolean
        default: true
      build_amxbf16:
        description: 'Build amxbf16 (AMD64 only)'
        required: false
        type: boolean
        default: true
      platforms:
        description: 'Target platforms (all, linux/amd64, linux/arm64)'
        required: false
        type: string
        default: 'all'
      version_postfix:
        description: 'Version postfix (e.g., .post1, .dev2, .rc1)'
        required: false
        type: string
        default: ''
      skip_pypi:
        description: 'Whether PyPI publishing is skipped'
        required: false
        type: boolean
        default: false
      skip_github_release:
        description: 'Whether GitHub release is skipped'
        required: false
        type: boolean
        default: false
    outputs:
      build_matrix:
        description: 'JSON matrix for unified build jobs (empty array [] if no builds)'
        value: ${{ jobs.check.outputs.build_matrix }}
      has_builds:
        description: 'Whether there are builds to run (true/false)'
        value: ${{ jobs.check.outputs.has_builds }}
      new_versions:
        description: 'JSON array of versions to build'
        value: ${{ jobs.check.outputs.new_versions }}
      version_postfix:
        description: 'Normalized version postfix'
        value: ${{ jobs.check.outputs.version_postfix }}
      build_amd64:
        description: 'Whether AMD64 builds are enabled'
        value: ${{ jobs.check.outputs.build_amd64 }}
      build_arm64:
        description: 'Whether ARM64 builds are enabled'
        value: ${{ jobs.check.outputs.build_arm64 }}

jobs:
  check:
    name: Check Versions & Generate Matrix
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      build_matrix: ${{ steps.matrix.outputs.build_matrix }}
      has_builds: ${{ steps.matrix.outputs.has_builds }}
      new_versions: ${{ steps.compare.outputs.new_versions }}
      version_postfix: ${{ steps.postfix.outputs.postfix }}
      build_amd64: ${{ steps.platforms.outputs.build_amd64 }}
      build_arm64: ${{ steps.platforms.outputs.build_arm64 }}

    steps:
      - name: Validate version postfix
        id: postfix
        run: |
          POSTFIX="${{ inputs.version_postfix }}"

          if [[ -z "$POSTFIX" ]]; then
            echo "No version postfix specified"
            echo "postfix=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Normalize postfix: add leading dot if missing
          # Accepts: post1, .post1, dev2, .dev2, rc1, .rc1, a1, .a1, b1, .b1
          if [[ "$POSTFIX" =~ ^\.?(post|dev|a|b|rc)([0-9]+)$ ]]; then
            TYPE="${BASH_REMATCH[1]}"
            NUM="${BASH_REMATCH[2]}"
            NORMALIZED=".${TYPE}${NUM}"
            echo "Input postfix: $POSTFIX -> Normalized: $NORMALIZED"
            echo "postfix=$NORMALIZED" >> "$GITHUB_OUTPUT"
          else
            echo "::error::Invalid version postfix '$POSTFIX'. Must match pattern: post1, .post1, dev2, .dev2, rc1, a1, b1, etc."
            exit 1
          fi

      - name: Fetch vLLM releases from GitHub
        id: github
        run: |
          echo "Fetching vLLM releases from GitHub..."

          # Use GitHub token for higher rate limits (5000/hour vs 60/hour)
          # Fetch all releases >= 0.8.5 (no older versions needed)
          GITHUB_VERSIONS=$(curl -sfL --retry 3 --retry-delay 5 \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/vllm-project/vllm/releases?per_page=100" | \
            jq -r '.[].tag_name' | \
            grep -E '^v[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?$' | \
            sed 's/^v//' | \
            sort -V | \
            awk -F. '$1 > 0 || ($1 == 0 && ($2 > 8 || ($2 == 8 && $3 >= 5)))')

          if [[ -z "$GITHUB_VERSIONS" ]]; then
            echo "::error::Failed to fetch vLLM releases from GitHub (possible rate limit)"
            exit 1
          fi

          echo "GitHub versions (stable only):"
          echo "$GITHUB_VERSIONS"

          # Save to file for later use
          echo "$GITHUB_VERSIONS" > /tmp/github_versions.txt

      - name: Fetch existing versions from PyPI
        id: pypi
        run: |
          echo "Fetching existing versions from PyPI..."

          # Query PyPI for vllm-cpu package versions with retry
          # Fetch ALL versions including .postN suffixes for accurate detection
          PYPI_ALL_VERSIONS=$(curl -sfL --retry 3 --retry-delay 5 \
            "https://pypi.org/pypi/vllm-cpu/json" | \
            jq -r '.releases | keys[]' | \
            grep -E '^[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?(\.post[0-9]+)?$' | \
            sort -V)

          if [[ -z "$PYPI_ALL_VERSIONS" ]]; then
            echo "::warning::Failed to fetch PyPI versions, assuming no existing versions"
            touch /tmp/pypi_all_versions.txt
            touch /tmp/pypi_base_versions.txt
          else
            echo "$PYPI_ALL_VERSIONS" > /tmp/pypi_all_versions.txt

            # Extract unique base versions (strip .postN suffix)
            # e.g., 0.12.0.post2 -> 0.12.0
            PYPI_BASE_VERSIONS=$(echo "$PYPI_ALL_VERSIONS" | \
              sed 's/\.post[0-9]*$//' | \
              sort -V -u)
            echo "$PYPI_BASE_VERSIONS" > /tmp/pypi_base_versions.txt

            echo "PyPI versions (all, including .postN):"
            echo "$PYPI_ALL_VERSIONS"
            echo ""
            echo "PyPI base versions (unique):"
            echo "$PYPI_BASE_VERSIONS"
          fi

      - name: Compare versions
        id: compare
        shell: bash
        run: |
          echo "Comparing versions..."

          # Handle vllm_versions input
          # Supports mixed formats with spaces:
          #   - Single: "0.12.0"
          #   - List: "0.11.0, 0.11.1, 0.12.0"
          #   - Range: "0.11.0-0.12.0"
          #   - Mixed: "0.8.5, 0.11.0-0.11.2, 0.12.0"
          #   - Complex: "0.8.5-0.9.0, 0.9.0.1, 0.9.2-0.10.1"
          INPUT_VERSIONS="${{ inputs.vllm_versions }}"
          if [[ -n "$INPUT_VERSIONS" ]]; then
            echo "Manual version input: $INPUT_VERSIONS"

            # Function to expand a version range into individual versions
            expand_range() {
              local start_ver="$1"
              local end_ver="$2"
              local result=""

              while IFS= read -r ver; do
                if [[ -n "$ver" ]]; then
                  # Check if version is within range (inclusive)
                  if [[ $(echo -e "$start_ver\n$ver" | sort -V | head -1) == "$start_ver" ]] && \
                     [[ $(echo -e "$ver\n$end_ver" | sort -V | head -1) == "$ver" ]]; then
                    if [[ -n "$result" ]]; then
                      result="$result,$ver"
                    else
                      result="$ver"
                    fi
                  fi
                fi
              done < /tmp/github_versions.txt
              echo "$result"
            }

            # Parse the input - supports mixed ranges and individual versions
            PARSED_VERSIONS=""
            SKIPPED_VERSIONS=""

            # Split by comma, handling spaces
            IFS=',' read -ra INPUT_ARRAY <<< "$INPUT_VERSIONS"
            for item in "${INPUT_ARRAY[@]}"; do
              # Trim leading/trailing whitespace
              item=$(echo "$item" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

              # Skip empty items
              [[ -z "$item" ]] && continue

              # Check if this item is a range (e.g., "0.11.0-0.12.0")
              # Version pattern: X.Y.Z or X.Y.Z.W
              if [[ "$item" =~ ^([0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?)-([0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?)$ ]]; then
                START_VER="${BASH_REMATCH[1]}"
                END_VER="${BASH_REMATCH[3]}"
                echo "Expanding range: $START_VER to $END_VER"

                RANGE_VERSIONS=$(expand_range "$START_VER" "$END_VER")
                if [[ -n "$RANGE_VERSIONS" ]]; then
                  echo "  Found versions: $RANGE_VERSIONS"
                  if [[ -n "$PARSED_VERSIONS" ]]; then
                    PARSED_VERSIONS="$PARSED_VERSIONS,$RANGE_VERSIONS"
                  else
                    PARSED_VERSIONS="$RANGE_VERSIONS"
                  fi
                else
                  echo "::warning::No versions found in range $START_VER to $END_VER"
                fi
              else
                # Single version - validate against available versions
                if grep -qx "$item" /tmp/github_versions.txt; then
                  echo "Found version: $item"
                  if [[ -n "$PARSED_VERSIONS" ]]; then
                    PARSED_VERSIONS="$PARSED_VERSIONS,$item"
                  else
                    PARSED_VERSIONS="$item"
                  fi
                else
                  echo "::warning::vLLM version $item not found in GitHub releases - skipping"
                  if [[ -n "$SKIPPED_VERSIONS" ]]; then
                    SKIPPED_VERSIONS="$SKIPPED_VERSIONS, $item"
                  else
                    SKIPPED_VERSIONS="$item"
                  fi
                fi
              fi
            done

            if [[ -n "$SKIPPED_VERSIONS" ]]; then
              echo "Skipped unavailable versions: $SKIPPED_VERSIONS"
            fi

            if [[ -z "$PARSED_VERSIONS" ]]; then
              echo "::error::No valid vLLM versions found. Requested: $INPUT_VERSIONS"
              echo "new_versions=[]" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # Remove duplicates, empty lines, and sort versions
            PARSED_VERSIONS=$(echo "$PARSED_VERSIONS" | tr ',' '\n' | grep -v '^$' | sort -V | uniq | tr '\n' ',' | sed 's/,$//')

            # Convert to JSON array
            JSON_ARRAY=$(echo "$PARSED_VERSIONS" | tr ',' '\n' | jq -R . | jq -s -c .)
            echo "Valid versions to build: $PARSED_VERSIONS"
            echo "new_versions=$JSON_ARRAY" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Function to check if a base version OR any .postN version exists on PyPI
          # Returns 0 (success/true) if version exists, 1 (failure/false) otherwise
          version_exists_on_pypi() {
            local base_ver="$1"
            # Check exact base version
            if grep -qx "$base_ver" /tmp/pypi_all_versions.txt 2>/dev/null; then
              return 0
            fi
            # Check any postfix version (base.post1, base.post2, etc.)
            if grep -qE "^${base_ver}\.post[0-9]+$" /tmp/pypi_all_versions.txt 2>/dev/null; then
              return 0
            fi
            return 1
          }

          # Auto-detect: Find versions in GitHub but not in PyPI (base or postfix)
          NEW_VERSIONS=""
          while IFS= read -r version; do
            if [[ -n "$version" ]]; then
              if ! version_exists_on_pypi "$version"; then
                echo "New version found: $version (no base or .postN on PyPI)"
                if [[ -n "$NEW_VERSIONS" ]]; then
                  NEW_VERSIONS="$NEW_VERSIONS,$version"
                else
                  NEW_VERSIONS="$version"
                fi
              else
                # Log what exists for debugging
                EXISTING=$(grep -E "^${version}(\.post[0-9]+)?$" /tmp/pypi_all_versions.txt 2>/dev/null | tr '\n' ', ' | sed 's/,$//')
                echo "Skipping $version - already on PyPI as: $EXISTING"
              fi
            fi
          done < /tmp/github_versions.txt

          if [[ -z "$NEW_VERSIONS" ]]; then
            echo "No new versions found"
            echo "new_versions=[]" >> "$GITHUB_OUTPUT"
          else
            echo "New versions to build: $NEW_VERSIONS"
            # Convert comma-separated to JSON array
            JSON_ARRAY=$(echo "$NEW_VERSIONS" | tr ',' '\n' | jq -R . | jq -s -c .)
            echo "new_versions=$JSON_ARRAY" >> "$GITHUB_OUTPUT"
          fi

      - name: Determine platforms
        id: platforms
        run: |
          SELECTED_PLATFORM="${{ inputs.platforms }}"
          echo "Selected platform: $SELECTED_PLATFORM"

          if [[ "$SELECTED_PLATFORM" == "all" || "$SELECTED_PLATFORM" == "linux/amd64" ]]; then
            echo "build_amd64=true" >> "$GITHUB_OUTPUT"
          else
            echo "build_amd64=false" >> "$GITHUB_OUTPUT"
          fi

          if [[ "$SELECTED_PLATFORM" == "all" || "$SELECTED_PLATFORM" == "linux/arm64" ]]; then
            echo "build_arm64=true" >> "$GITHUB_OUTPUT"
          else
            echo "build_arm64=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Generate unified build matrix
        id: matrix
        shell: bash
        run: |
          # Read versions from previous step
          VERSIONS_JSON='${{ steps.compare.outputs.new_versions }}'

          # Check if we have any versions to build
          if [[ "$VERSIONS_JSON" == "[]" || -z "$VERSIONS_JSON" ]]; then
            echo "No versions to build"
            echo "build_matrix=[]" >> "$GITHUB_OUTPUT"
            echo "has_builds=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Platform flags
          BUILD_AMD64="${{ steps.platforms.outputs.build_amd64 }}"
          BUILD_ARM64="${{ steps.platforms.outputs.build_arm64 }}"

          # Variant flags
          BUILD_NOAVX512="${{ inputs.build_noavx512 }}"
          BUILD_AVX512="${{ inputs.build_avx512 }}"
          BUILD_AVX512VNNI="${{ inputs.build_avx512vnni }}"
          BUILD_AVX512BF16="${{ inputs.build_avx512bf16 }}"
          BUILD_AMXBF16="${{ inputs.build_amxbf16 }}"

          echo "=== Build Configuration ==="
          echo "Versions: $VERSIONS_JSON"
          echo "Platforms: AMD64=$BUILD_AMD64, ARM64=$BUILD_ARM64"
          echo "Variants: noavx512=$BUILD_NOAVX512, avx512=$BUILD_AVX512, avx512vnni=$BUILD_AVX512VNNI, avx512bf16=$BUILD_AVX512BF16, amxbf16=$BUILD_AMXBF16"

          # Function to check if platform-specific wheel exists on PyPI
          # Checks both base version AND any .postN versions
          # Args: $1=package_name, $2=base_version, $3=platform_tag (x86_64 or aarch64)
          check_wheel_exists() {
            local pkg="$1"
            local base_ver="$2"
            local plat="$3"
            local pkg_underscore="${pkg//-/_}"

            # First try exact base version
            local response
            response=$(curl -sf "https://pypi.org/pypi/${pkg}/${base_ver}/json" 2>/dev/null)
            if [[ $? -eq 0 ]] && echo "$response" | grep -qE "\"filename\":\s*\"${pkg_underscore}-[^\"]*${plat}"; then
              return 0  # Wheel exists for base version
            fi

            # Try postfix versions (.post1, .post2, etc.)
            # Get all versions of this package that match base.postN
            local all_versions
            all_versions=$(curl -sf "https://pypi.org/pypi/${pkg}/json" 2>/dev/null | \
              jq -r '.releases | keys[]' 2>/dev/null | \
              grep -E "^${base_ver}\.post[0-9]+$" | \
              sort -V)

            local postfix_ver
            for postfix_ver in $all_versions; do
              response=$(curl -sf "https://pypi.org/pypi/${pkg}/${postfix_ver}/json" 2>/dev/null)
              if [[ $? -eq 0 ]] && echo "$response" | grep -qE "\"filename\":\s*\"${pkg_underscore}-[^\"]*${plat}"; then
                return 0  # Wheel exists for postfix version
              fi
            done

            return 1  # No wheel found for base or any postfix version
          }

          # Map variant to package name
          variant_to_package() {
            case "$1" in
              noavx512) echo "vllm-cpu" ;;
              avx512) echo "vllm-cpu-avx512" ;;
              avx512vnni) echo "vllm-cpu-avx512vnni" ;;
              avx512bf16) echo "vllm-cpu-avx512bf16" ;;
              amxbf16) echo "vllm-cpu-amxbf16" ;;
              *) echo "vllm-cpu" ;;
            esac
          }

          # Map platform to wheel tag
          platform_to_tag() {
            case "$1" in
              amd64) echo "x86_64" ;;
              arm64) echo "aarch64" ;;
              *) echo "x86_64" ;;
            esac
          }

          # Generate the build matrix using jq
          # This creates a flat array of {variant, platform, version} objects
          MATRIX=$(echo "$VERSIONS_JSON" | jq -c --arg build_amd64 "$BUILD_AMD64" \
                                                  --arg build_arm64 "$BUILD_ARM64" \
                                                  --arg build_noavx512 "$BUILD_NOAVX512" \
                                                  --arg build_avx512 "$BUILD_AVX512" \
                                                  --arg build_avx512vnni "$BUILD_AVX512VNNI" \
                                                  --arg build_avx512bf16 "$BUILD_AVX512BF16" \
                                                  --arg build_amxbf16 "$BUILD_AMXBF16" '
            . as $versions |
            [
              # noavx512 for AMD64
              (if ($build_noavx512 == "true" and $build_amd64 == "true") then
                $versions[] | {variant: "noavx512", platform: "amd64", version: .}
              else empty end),

              # noavx512 for ARM64
              (if ($build_noavx512 == "true" and $build_arm64 == "true") then
                $versions[] | {variant: "noavx512", platform: "arm64", version: .}
              else empty end),

              # AVX512 variants (AMD64 only)
              (if ($build_avx512 == "true" and $build_amd64 == "true") then
                $versions[] | {variant: "avx512", platform: "amd64", version: .}
              else empty end),

              (if ($build_avx512vnni == "true" and $build_amd64 == "true") then
                $versions[] | {variant: "avx512vnni", platform: "amd64", version: .}
              else empty end),

              (if ($build_avx512bf16 == "true" and $build_amd64 == "true") then
                $versions[] | {variant: "avx512bf16", platform: "amd64", version: .}
              else empty end),

              (if ($build_amxbf16 == "true" and $build_amd64 == "true") then
                $versions[] | {variant: "amxbf16", platform: "amd64", version: .}
              else empty end)
            ]
          ')

          echo "Initial matrix (before platform wheel check):"
          echo "$MATRIX" | jq .

          # Filter matrix: remove entries where platform-specific wheel already exists on PyPI
          # Now checks for BOTH base version AND any .postN versions
          echo ""
          echo "=== Checking for existing platform-specific wheels on PyPI ==="
          FILTERED_MATRIX="[]"

          # Get version postfix (e.g., .post2) if manually specified
          VERSION_POSTFIX="${{ steps.postfix.outputs.postfix }}"
          echo "DEBUG: Raw postfix from input: '${{ inputs.version_postfix }}'"
          echo "DEBUG: Normalized postfix from step: '$VERSION_POSTFIX'"
          if [[ -n "$VERSION_POSTFIX" ]]; then
            echo "Using specific version postfix: $VERSION_POSTFIX"
            echo "Will only check for this exact version on PyPI"
          else
            echo "No version postfix specified - will check base AND any .postN versions on PyPI"
          fi

          for entry in $(echo "$MATRIX" | jq -c '.[]'); do
            variant=$(echo "$entry" | jq -r '.variant')
            platform=$(echo "$entry" | jq -r '.platform')
            base_version=$(echo "$entry" | jq -r '.version')

            package=$(variant_to_package "$variant")
            plat_tag=$(platform_to_tag "$platform")

            if [[ -n "$VERSION_POSTFIX" ]]; then
              # Specific postfix requested - check only that exact version
              pypi_version="${base_version}${VERSION_POSTFIX}"
              if check_wheel_exists "$package" "$pypi_version" "$plat_tag"; then
                echo "SKIP: $package v$pypi_version ($plat_tag) - wheel exists on PyPI"
              else
                echo "BUILD: $package v$pypi_version ($plat_tag) - wheel not found on PyPI"
                FILTERED_MATRIX=$(echo "$FILTERED_MATRIX" | jq -c --argjson entry "$entry" '. + [$entry]')
              fi
            else
              # No postfix - check base version AND any .postN versions
              # check_wheel_exists already handles this (checks base + all .postN)
              if check_wheel_exists "$package" "$base_version" "$plat_tag"; then
                echo "SKIP: $package v$base_version ($plat_tag) - wheel exists on PyPI (base or .postN)"
              else
                echo "BUILD: $package v$base_version ($plat_tag) - no wheel found on PyPI"
                FILTERED_MATRIX=$(echo "$FILTERED_MATRIX" | jq -c --argjson entry "$entry" '. + [$entry]')
              fi
            fi
          done

          echo ""
          echo "Filtered matrix (after platform wheel check):"
          echo "$FILTERED_MATRIX" | jq .

          # Check if matrix is empty
          MATRIX_LENGTH=$(echo "$FILTERED_MATRIX" | jq 'length')
          if [[ "$MATRIX_LENGTH" -eq 0 ]]; then
            echo "No builds in matrix (all wheels already exist or variants/platforms disabled)"
            echo "build_matrix=[]" >> "$GITHUB_OUTPUT"
            echo "has_builds=false" >> "$GITHUB_OUTPUT"
          else
            echo "Matrix has $MATRIX_LENGTH builds"
            # Wrap in include for GitHub Actions matrix format
            FINAL_MATRIX=$(echo "$FILTERED_MATRIX" | jq -c '{include: .}')
            echo "build_matrix=$FINAL_MATRIX" >> "$GITHUB_OUTPUT"
            echo "has_builds=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Summary
        run: |
          echo "=========================================="
          echo "Version Check Summary"
          echo "=========================================="
          echo "New versions: ${{ steps.compare.outputs.new_versions }}"
          echo "Version postfix: ${{ steps.postfix.outputs.postfix || '(none)' }}"
          echo "Build AMD64: ${{ steps.platforms.outputs.build_amd64 }}"
          echo "Build ARM64: ${{ steps.platforms.outputs.build_arm64 }}"
          echo "Has builds: ${{ steps.matrix.outputs.has_builds }}"
          echo "Build matrix: ${{ steps.matrix.outputs.build_matrix }}"
          echo "=========================================="

          # Add to job summary
          {
            echo "## Version Check Results"
            echo ""
            echo "| Property | Value |"
            echo "|----------|-------|"
            echo "| Versions | \`${{ steps.compare.outputs.new_versions }}\` |"
            echo "| Postfix | \`${{ steps.postfix.outputs.postfix || '(none)' }}\` |"
            echo "| AMD64 | ${{ steps.platforms.outputs.build_amd64 }} |"
            echo "| ARM64 | ${{ steps.platforms.outputs.build_arm64 }} |"
            echo "| Has Builds | ${{ steps.matrix.outputs.has_builds }} |"
            echo "| Skip PyPI | ${{ inputs.skip_pypi == true }} |"
            echo "| Skip GitHub Release | ${{ inputs.skip_github_release == true }} |"
            echo ""
            echo "### Build Matrix"
            echo ""
            echo "\`\`\`json"
            echo '${{ steps.matrix.outputs.build_matrix }}' | jq .
            echo "\`\`\`"
          } >> "$GITHUB_STEP_SUMMARY"
