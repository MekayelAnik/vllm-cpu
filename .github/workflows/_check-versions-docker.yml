# =============================================================================
# Reusable Workflow: Check Versions for Docker Image Builds
# =============================================================================
# Extends _check-versions.yml with Docker-specific logic:
# - Checks existing Docker Hub/GHCR images
# - Determines if latest tags need updating
# - Handles version postfix detection from PyPI
# - Generates Docker-specific build matrix
#
# Usage:
#   jobs:
#     check-versions:
#       uses: ./.github/workflows/_check-versions-docker.yml
#       with:
#         vllm_versions: "0.12.0"
#         build_noavx512: true
#       secrets: inherit
# =============================================================================

name: Check Versions for Docker (Reusable)

on:
  workflow_call:
    inputs:
      vllm_versions:
        description: 'vLLM versions (e.g., 0.12.0 or 0.11.2,0.12.0 or 0.11.0-0.12.0) - leave empty for auto-detect'
        required: false
        type: string
        default: ''
      build_noavx512:
        description: 'Build noavx512 (universal, AMD64+ARM64)'
        required: false
        type: boolean
        default: true
      build_avx512:
        description: 'Build avx512 (AMD64 only)'
        required: false
        type: boolean
        default: true
      build_avx512vnni:
        description: 'Build avx512vnni (AMD64 only)'
        required: false
        type: boolean
        default: true
      build_avx512bf16:
        description: 'Build avx512bf16 (AMD64 only)'
        required: false
        type: boolean
        default: true
      build_amxbf16:
        description: 'Build amxbf16 (AMD64 only)'
        required: false
        type: boolean
        default: true
      platforms:
        description: 'Target platforms (all, linux/amd64, linux/arm64)'
        required: false
        type: string
        default: 'all'
      version_postfix:
        description: 'Version postfix (e.g., .post1, .dev2, .rc1)'
        required: false
        type: string
        default: ''
      use_highest_postfix:
        description: 'Auto-detect highest postfix from PyPI'
        required: false
        type: boolean
        default: false
      use_github_release:
        description: 'Use GitHub release wheels instead of PyPI'
        required: false
        type: boolean
        default: false
      skip_dockerhub:
        description: 'Skip Docker Hub publishing'
        required: false
        type: boolean
        default: false
      skip_ghcr:
        description: 'Skip GitHub Container Registry publishing'
        required: false
        type: boolean
        default: false
      force_rebuild_dockerhub:
        description: 'Force rebuild Docker Hub images'
        required: false
        type: boolean
        default: false
      force_rebuild_ghcr:
        description: 'Force rebuild GHCR images'
        required: false
        type: boolean
        default: false
      dockerhub_image:
        description: 'Docker Hub image name'
        required: false
        type: string
        default: 'mekayelanik/vllm-cpu'
      ghcr_image:
        description: 'GHCR image name'
        required: false
        type: string
        default: 'ghcr.io/mekayelanik/vllm-cpu'

    outputs:
      # From base _check-versions.yml
      build_matrix:
        description: 'JSON matrix for Docker builds'
        value: ${{ jobs.docker-check.outputs.build_matrix }}
      has_builds:
        description: 'Whether there are builds to run'
        value: ${{ jobs.docker-check.outputs.has_builds }}
      new_versions:
        description: 'JSON array of versions to build'
        value: ${{ jobs.base-check.outputs.new_versions }}
      version_postfix:
        description: 'Normalized version postfix'
        value: ${{ jobs.docker-check.outputs.version_postfix }}
      build_amd64:
        description: 'Whether AMD64 builds are enabled'
        value: ${{ jobs.base-check.outputs.build_amd64 }}
      build_arm64:
        description: 'Whether ARM64 builds are enabled'
        value: ${{ jobs.base-check.outputs.build_arm64 }}
      # Docker-specific outputs
      latest_version:
        description: 'Latest vLLM version from PyPI'
        value: ${{ jobs.docker-check.outputs.latest_version }}
      needs_latest_update:
        description: 'Whether latest tags need updating'
        value: ${{ jobs.docker-check.outputs.needs_latest_update }}
      use_github_release:
        description: 'Whether to use GitHub release wheels'
        value: ${{ jobs.docker-check.outputs.use_github_release }}
      variants_matrix:
        description: 'JSON array of variants to build'
        value: ${{ jobs.docker-check.outputs.variants_matrix }}

jobs:
  # ==========================================================================
  # Call base version check workflow for version parsing
  # ==========================================================================
  base-check:
    name: Base Version Check
    uses: ./.github/workflows/_check-versions.yml
    with:
      vllm_versions: ${{ inputs.vllm_versions }}
      build_noavx512: ${{ inputs.build_noavx512 }}
      build_avx512: ${{ inputs.build_avx512 }}
      build_avx512vnni: ${{ inputs.build_avx512vnni }}
      build_avx512bf16: ${{ inputs.build_avx512bf16 }}
      build_amxbf16: ${{ inputs.build_amxbf16 }}
      platforms: ${{ inputs.platforms }}
      version_postfix: ${{ inputs.version_postfix }}
    secrets: inherit

  # ==========================================================================
  # Docker-specific checks
  # ==========================================================================
  docker-check:
    name: Docker-Specific Checks
    needs: base-check
    runs-on: ubuntu-latest
    timeout-minutes: 10

    outputs:
      build_matrix: ${{ steps.matrix.outputs.build_matrix }}
      has_builds: ${{ steps.matrix.outputs.has_builds }}
      latest_version: ${{ steps.latest.outputs.version }}
      needs_latest_update: ${{ steps.latest.outputs.needs_update }}
      version_postfix: ${{ steps.postfix.outputs.postfix }}
      use_github_release: ${{ steps.postfix.outputs.use_github_release }}
      variants_matrix: ${{ steps.variants.outputs.matrix }}
      new_versions: ${{ steps.auto-detect.outputs.new_versions || needs.base-check.outputs.new_versions }}

    steps:
      # ========================================================================
      # Docker Auto-Detect: Find PyPI versions not yet in Docker Hub
      # This overrides base-check's logic which compares GitHub vs PyPI
      # For Docker, we need: PyPI base versions NOT in Docker Hub
      # Also detects if newer .postN exists to trigger rebuild
      # ========================================================================
      - name: Auto-detect versions for Docker (PyPI vs Docker Hub)
        id: auto-detect
        if: inputs.vllm_versions == ''
        shell: bash
        run: |
          echo "Auto-detect mode: Finding PyPI versions without Docker images..."

          # Fetch ALL versions from PyPI (including .postN)
          echo "Fetching PyPI versions..."
          PYPI_ALL_VERSIONS=""
          for attempt in 1 2 3; do
            PYPI_ALL_VERSIONS=$(curl -sS --retry 3 --retry-delay 5 \
              "https://pypi.org/pypi/vllm-cpu/json" | \
              jq -r '.releases | keys[]' | \
              grep -E '^[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?(\.post[0-9]+)?$' | \
              sort -V || echo "") && break
            echo "Attempt $attempt failed, retrying..."
            sleep 5
          done

          if [[ -z "$PYPI_ALL_VERSIONS" ]]; then
            echo "::error::Failed to fetch PyPI versions"
            echo "new_versions=[]" >> "$GITHUB_OUTPUT"
            echo "is_auto_detect=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "$PYPI_ALL_VERSIONS" > /tmp/pypi_all_versions.txt

          # Extract unique base versions (strip .postN suffix)
          PYPI_BASE_VERSIONS=$(echo "$PYPI_ALL_VERSIONS" | \
            sed 's/\.post[0-9]*$//' | \
            sort -V -u)
          echo "$PYPI_BASE_VERSIONS" > /tmp/pypi_base_versions.txt

          echo "PyPI versions found (all including .postN):"
          echo "$PYPI_ALL_VERSIONS"
          echo ""
          echo "PyPI base versions (unique):"
          echo "$PYPI_BASE_VERSIONS"

          # Fetch existing Docker Hub tags
          echo ""
          echo "Fetching Docker Hub tags..."
          DOCKERHUB_TAGS=""
          for attempt in 1 2 3; do
            DOCKERHUB_TAGS=$(curl -sS --retry 3 --retry-delay 5 \
              "https://hub.docker.com/v2/repositories/${{ inputs.dockerhub_image }}/tags?page_size=100" | \
              jq -r '.results[].name' 2>/dev/null || echo "") && break
            sleep 5
          done

          # Extract version numbers from Docker tags (these are always base versions)
          DOCKER_VERSIONS=""
          if [[ -n "$DOCKERHUB_TAGS" ]]; then
            DOCKER_VERSIONS=$(echo "$DOCKERHUB_TAGS" | \
              grep -oE '[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?' | \
              sort -V -u || echo "")
            echo "Docker Hub versions found:"
            echo "$DOCKER_VERSIONS"
          else
            echo "No Docker Hub tags found or failed to fetch"
          fi
          echo "$DOCKER_VERSIONS" > /tmp/docker_versions.txt

          # Function to get highest wheel version for a base version from PyPI
          get_highest_wheel_version() {
            local base_ver="$1"
            # Get all versions matching this base (including base itself and .postN)
            local matching
            matching=$(grep -E "^${base_ver}(\.post[0-9]+)?$" /tmp/pypi_all_versions.txt | sort -V)
            if [[ -n "$matching" ]]; then
              echo "$matching" | tail -1
            else
              echo ""
            fi
          }

          # Function to check if wheel exists in GitHub releases
          check_github_release_wheel() {
            local base_ver="$1"
            # Check if a GitHub release exists with vllm-cpu wheels
            local release_info
            release_info=$(curl -sS --retry 2 --retry-delay 3 \
              "https://api.github.com/repos/${{ github.repository }}/releases/tags/v${base_ver}" 2>/dev/null)
            if [[ $? -eq 0 ]] && echo "$release_info" | jq -e '.assets[] | select(.name | contains("vllm_cpu"))' > /dev/null 2>&1; then
              return 0  # Wheel found in GitHub release
            fi
            return 1  # No wheel in GitHub release
          }

          # Function to get PyPI release date for a version
          get_pypi_release_date() {
            local version="$1"
            curl -sS --retry 2 --retry-delay 3 \
              "https://pypi.org/pypi/vllm-cpu/${version}/json" 2>/dev/null | \
              jq -r '.urls[0].upload_time_iso_8601 // ""' 2>/dev/null
          }

          # Function to get Docker image last updated date
          get_docker_last_updated() {
            local base_ver="$1"
            local variant="noavx512"
            local image="${{ inputs.dockerhub_image }}"
            local tag="${variant}-${base_ver}"

            curl -sS --retry 2 --retry-delay 3 \
              "https://hub.docker.com/v2/repositories/${image}/tags/${tag}" 2>/dev/null | \
              jq -r '.last_updated // ""' 2>/dev/null
          }

          # Find PyPI base versions not in Docker Hub
          # Also check for versions that need rebuild (newer .postN available after image was built)
          # And check GitHub releases for versions not on PyPI
          echo ""
          echo "Finding versions to build..."
          NEW_VERSIONS=""
          REBUILD_VERSIONS=""
          GITHUB_RELEASE_VERSIONS=""  # Versions that need GitHub release wheels

          while IFS= read -r base_version; do
            if [[ -n "$base_version" ]]; then
              HIGHEST_WHEEL=$(get_highest_wheel_version "$base_version")

              if ! grep -qx "$base_version" /tmp/docker_versions.txt 2>/dev/null; then
                # Docker image doesn't exist for this base version
                if [[ -n "$HIGHEST_WHEEL" ]]; then
                  echo "  NEW: $base_version (PyPI wheel: $HIGHEST_WHEEL)"
                  if [[ -n "$NEW_VERSIONS" ]]; then
                    NEW_VERSIONS="$NEW_VERSIONS,$base_version"
                  else
                    NEW_VERSIONS="$base_version"
                  fi
                fi
              else
                # Docker image exists - check if rebuild needed
                if [[ -n "$HIGHEST_WHEEL" && "$HIGHEST_WHEEL" != "$base_version" ]]; then
                  # A .postN wheel exists - check if it's newer than the Docker image
                  DOCKER_DATE=$(get_docker_last_updated "$base_version")
                  WHEEL_DATE=$(get_pypi_release_date "$HIGHEST_WHEEL")

                  if [[ -n "$DOCKER_DATE" && -n "$WHEEL_DATE" ]]; then
                    # Compare dates - rebuild if wheel is newer
                    DOCKER_TS=$(date -d "$DOCKER_DATE" +%s 2>/dev/null || echo "0")
                    WHEEL_TS=$(date -d "$WHEEL_DATE" +%s 2>/dev/null || echo "0")

                    if [[ "$WHEEL_TS" -gt "$DOCKER_TS" ]]; then
                      echo "  REBUILD: $base_version (wheel $HIGHEST_WHEEL released after Docker image)"
                      echo "           Docker: $DOCKER_DATE, Wheel: $WHEEL_DATE"
                      if [[ -n "$REBUILD_VERSIONS" ]]; then
                        REBUILD_VERSIONS="$REBUILD_VERSIONS,$base_version"
                      else
                        REBUILD_VERSIONS="$base_version"
                      fi
                    else
                      echo "  EXISTS: $base_version (Docker image up-to-date with wheel $HIGHEST_WHEEL)"
                    fi
                  else
                    echo "  EXISTS: $base_version (cannot determine dates, skipping rebuild check)"
                  fi
                else
                  echo "  EXISTS: $base_version (no .postN wheel available)"
                fi
              fi
            fi
          done < /tmp/pypi_base_versions.txt

          # Also check GitHub releases for versions that might not be on PyPI yet
          # This handles the case where wheels are only available in GitHub releases
          echo ""
          echo "Checking GitHub releases for additional versions..."
          GH_RELEASES=$(curl -sS --retry 2 --retry-delay 3 \
            "https://api.github.com/repos/${{ github.repository }}/releases?per_page=20" 2>/dev/null | \
            jq -r '.[].tag_name' 2>/dev/null | \
            grep -E '^v[0-9]+\.[0-9]+\.[0-9]+' | \
            sed 's/^v//' | \
            sort -V -u || echo "")

          for gh_version in $GH_RELEASES; do
            # Skip if already in our lists or has Docker image
            if echo "$NEW_VERSIONS,$REBUILD_VERSIONS" | tr ',' '\n' | grep -qx "$gh_version" 2>/dev/null; then
              continue
            fi
            if grep -qx "$gh_version" /tmp/docker_versions.txt 2>/dev/null; then
              continue
            fi
            # Skip if PyPI has this version (already handled above)
            if grep -qx "$gh_version" /tmp/pypi_base_versions.txt 2>/dev/null; then
              continue
            fi

            # Check if this GitHub release has wheels
            if check_github_release_wheel "$gh_version"; then
              echo "  NEW (GitHub Release): $gh_version"
              if [[ -n "$GITHUB_RELEASE_VERSIONS" ]]; then
                GITHUB_RELEASE_VERSIONS="$GITHUB_RELEASE_VERSIONS,$gh_version"
              else
                GITHUB_RELEASE_VERSIONS="$gh_version"
              fi
            fi
          done

          # Combine all versions
          ALL_VERSIONS="$NEW_VERSIONS"
          if [[ -n "$REBUILD_VERSIONS" ]]; then
            if [[ -n "$ALL_VERSIONS" ]]; then
              ALL_VERSIONS="$ALL_VERSIONS,$REBUILD_VERSIONS"
            else
              ALL_VERSIONS="$REBUILD_VERSIONS"
            fi
          fi
          if [[ -n "$GITHUB_RELEASE_VERSIONS" ]]; then
            if [[ -n "$ALL_VERSIONS" ]]; then
              ALL_VERSIONS="$ALL_VERSIONS,$GITHUB_RELEASE_VERSIONS"
            else
              ALL_VERSIONS="$GITHUB_RELEASE_VERSIONS"
            fi
          fi

          if [[ -z "$ALL_VERSIONS" ]]; then
            echo "No new versions found - all versions have up-to-date Docker images"
            echo "new_versions=[]" >> "$GITHUB_OUTPUT"
            echo "wheel_versions={}" >> "$GITHUB_OUTPUT"
            echo "github_release_versions=" >> "$GITHUB_OUTPUT"
          else
            echo ""
            echo "Versions to build: $ALL_VERSIONS"
            JSON_ARRAY=$(echo "$ALL_VERSIONS" | tr ',' '\n' | sort -V -u | jq -R . | jq -s -c .)
            echo "new_versions=$JSON_ARRAY" >> "$GITHUB_OUTPUT"
            echo "github_release_versions=$GITHUB_RELEASE_VERSIONS" >> "$GITHUB_OUTPUT"

            # Create wheel_version mapping: base_version -> highest_wheel_version
            # This is used by the matrix to know which wheel to install for each Docker tag
            # For GitHub release-only versions, use the base version itself
            echo ""
            echo "Building wheel version mapping..."
            WHEEL_MAP="{"
            FIRST=true
            for base_version in $(echo "$ALL_VERSIONS" | tr ',' '\n' | sort -V -u); do
              HIGHEST_WHEEL=$(get_highest_wheel_version "$base_version")
              # If not on PyPI, use base version (will be fetched from GitHub release)
              if [[ -z "$HIGHEST_WHEEL" ]]; then
                HIGHEST_WHEEL="$base_version"
              fi
              if [[ "$FIRST" != "true" ]]; then
                WHEEL_MAP="${WHEEL_MAP},"
              fi
              WHEEL_MAP="${WHEEL_MAP}\"${base_version}\":\"${HIGHEST_WHEEL}\""
              FIRST=false
              echo "  $base_version -> $HIGHEST_WHEEL"
            done
            WHEEL_MAP="${WHEEL_MAP}}"
            echo "wheel_versions=$WHEEL_MAP" >> "$GITHUB_OUTPUT"
          fi

          echo "is_auto_detect=true" >> "$GITHUB_OUTPUT"

      - name: Get latest version from PyPI
        id: latest
        shell: bash
        run: |
          echo "Fetching latest version from PyPI..."

          # Retry logic for PyPI API
          PYPI_LATEST=""
          for attempt in 1 2 3; do
            PYPI_LATEST=$(curl -sS --retry 3 --retry-delay 5 \
              "https://pypi.org/pypi/vllm-cpu/json" | \
              jq -r '.info.version' | \
              grep -oE '^[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?' || echo "") && break
            echo "Attempt $attempt failed, retrying..."
            sleep 5
          done

          if [[ -z "$PYPI_LATEST" ]]; then
            # Fallback to highest version from new_versions
            VERSIONS='${{ needs.base-check.outputs.new_versions }}'
            PYPI_LATEST=$(echo "$VERSIONS" | jq -r '.[]' | sort -V | tail -1)
            echo "::warning::PyPI fetch failed, using highest from versions: $PYPI_LATEST"
          fi

          echo "Latest version: $PYPI_LATEST"
          echo "version=$PYPI_LATEST" >> "$GITHUB_OUTPUT"

          # Check if we're building the latest version
          NEW_VERSIONS='${{ needs.base-check.outputs.new_versions }}'
          BUILDING_LATEST="false"
          if echo "$NEW_VERSIONS" | jq -e --arg v "$PYPI_LATEST" 'index($v) != null' > /dev/null 2>&1; then
            BUILDING_LATEST="true"
            echo "Building the latest version - latest tags will be updated"
          fi

          echo "needs_update=$BUILDING_LATEST" >> "$GITHUB_OUTPUT"

      - name: Check existing Docker images
        id: existing
        if: needs.base-check.outputs.has_builds == 'true'
        shell: bash
        run: |
          FORCE_DOCKERHUB="${{ inputs.force_rebuild_dockerhub }}"
          FORCE_GHCR="${{ inputs.force_rebuild_ghcr }}"

          if [[ "$FORCE_DOCKERHUB" == "true" && "$FORCE_GHCR" == "true" ]]; then
            echo "Force rebuild enabled for both registries"
            echo "existing_versions=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Checking existing Docker Hub images..."

          DOCKERHUB_TAGS=""
          for attempt in 1 2 3; do
            DOCKERHUB_TAGS=$(curl -sS --retry 3 --retry-delay 5 \
              "https://hub.docker.com/v2/repositories/${{ inputs.dockerhub_image }}/tags?page_size=100" | \
              jq -r '.results[].name' 2>/dev/null || echo "") && break
            sleep 5
          done

          EXISTING_VERSIONS=""
          if [[ -n "$DOCKERHUB_TAGS" ]]; then
            EXISTING_VERSIONS=$(echo "$DOCKERHUB_TAGS" | \
              grep -oE '[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?' | \
              sort -V -u | tr '\n' ',' | sed 's/,$//')
            echo "Existing Docker versions: $EXISTING_VERSIONS"
          fi

          echo "existing_versions=$EXISTING_VERSIONS" >> "$GITHUB_OUTPUT"

      - name: Determine version postfix
        id: postfix
        shell: bash
        run: |
          BASE_POSTFIX="${{ needs.base-check.outputs.version_postfix }}"
          USE_HIGHEST="${{ inputs.use_highest_postfix }}"
          USE_GH_RELEASE="${{ inputs.use_github_release }}"

          # If base check already determined postfix, use it
          if [[ -n "$BASE_POSTFIX" ]]; then
            echo "Using postfix from base check: $BASE_POSTFIX"
            echo "postfix=$BASE_POSTFIX" >> "$GITHUB_OUTPUT"
            echo "use_github_release=$USE_GH_RELEASE" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # If use_highest_postfix is enabled, detect from PyPI
          if [[ "$USE_HIGHEST" == "true" ]]; then
            echo "Auto-detecting highest postfix from PyPI..."

            NEW_VERSIONS='${{ needs.base-check.outputs.new_versions }}'
            FIRST_VERSION=$(echo "$NEW_VERSIONS" | jq -r '.[0]')

            if [[ -n "$FIRST_VERSION" && "$FIRST_VERSION" != "null" ]]; then
              ALL_PYPI=$(curl -sS --retry 3 --retry-delay 5 \
                "https://pypi.org/pypi/vllm-cpu/json" | \
                jq -r '.releases | keys[]' 2>/dev/null || echo "")

              if [[ -n "$ALL_PYPI" ]]; then
                POSTFIX_VERSIONS=$(echo "$ALL_PYPI" | \
                  grep -E "^${FIRST_VERSION}\.(post|dev|rc|a|b)[0-9]+$" | \
                  sort -V)

                if [[ -n "$POSTFIX_VERSIONS" ]]; then
                  HIGHEST=$(echo "$POSTFIX_VERSIONS" | tail -1)
                  POSTFIX_PART=$(echo "$HIGHEST" | sed "s/^${FIRST_VERSION}//")
                  echo "Found highest postfix: $POSTFIX_PART"
                  echo "postfix=$POSTFIX_PART" >> "$GITHUB_OUTPUT"
                  echo "use_github_release=true" >> "$GITHUB_OUTPUT"
                  exit 0
                fi
              fi
            fi
          fi

          echo "No postfix"
          echo "postfix=" >> "$GITHUB_OUTPUT"
          echo "use_github_release=$USE_GH_RELEASE" >> "$GITHUB_OUTPUT"

      - name: Generate variants matrix
        id: variants
        shell: bash
        run: |
          VARIANTS=""

          if [[ "${{ inputs.build_noavx512 }}" == "true" ]]; then
            VARIANTS="${VARIANTS:+$VARIANTS,}noavx512"
          fi
          if [[ "${{ inputs.build_avx512 }}" == "true" ]]; then
            VARIANTS="${VARIANTS:+$VARIANTS,}avx512"
          fi
          if [[ "${{ inputs.build_avx512vnni }}" == "true" ]]; then
            VARIANTS="${VARIANTS:+$VARIANTS,}avx512vnni"
          fi
          if [[ "${{ inputs.build_avx512bf16 }}" == "true" ]]; then
            VARIANTS="${VARIANTS:+$VARIANTS,}avx512bf16"
          fi
          if [[ "${{ inputs.build_amxbf16 }}" == "true" ]]; then
            VARIANTS="${VARIANTS:+$VARIANTS,}amxbf16"
          fi

          if [[ -z "$VARIANTS" ]]; then
            echo "::warning::No variants selected"
            MATRIX='[]'
          else
            MATRIX=$(echo "$VARIANTS" | tr ',' '\n' | jq -R . | jq -s -c .)
          fi

          echo "Variants: $MATRIX"
          echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"

      - name: Generate Docker build matrix
        id: matrix
        shell: bash
        run: |
          # Use auto-detected versions if in auto-detect mode, otherwise use base-check
          IS_AUTO_DETECT="${{ steps.auto-detect.outputs.is_auto_detect }}"
          if [[ "$IS_AUTO_DETECT" == "true" ]]; then
            NEW_VERSIONS='${{ steps.auto-detect.outputs.new_versions }}'
            WHEEL_VERSIONS='${{ steps.auto-detect.outputs.wheel_versions }}'
            echo "Using auto-detected versions (PyPI vs Docker Hub)"
          else
            NEW_VERSIONS='${{ needs.base-check.outputs.new_versions }}'
            WHEEL_VERSIONS='{}'
            echo "Using manually specified versions"
          fi

          VARIANTS='${{ steps.variants.outputs.matrix }}'
          EXISTING="${{ steps.existing.outputs.existing_versions }}"

          # If no versions to build, exit early
          if [[ -z "$NEW_VERSIONS" || "$NEW_VERSIONS" == "[]" || "$NEW_VERSIONS" == "null" ]]; then
            echo "No versions to build"
            echo "build_matrix={\"include\":[]}" >> "$GITHUB_OUTPUT"
            echo "has_builds=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # For manual mode, filter out versions that already have Docker images (unless force rebuild)
          # For auto-detect mode, this is already done in the auto-detect step
          FORCE_DOCKERHUB="${{ inputs.force_rebuild_dockerhub }}"
          FORCE_GHCR="${{ inputs.force_rebuild_ghcr }}"

          FILTERED_VERSIONS="$NEW_VERSIONS"
          if [[ "$IS_AUTO_DETECT" != "true" && "$FORCE_DOCKERHUB" != "true" && "$FORCE_GHCR" != "true" && -n "$EXISTING" ]]; then
            # Filter versions - keep only those not in existing
            FILTERED_VERSIONS=$(echo "$NEW_VERSIONS" | jq -c --arg existing "$EXISTING" '
              ($existing | split(",")) as $ex |
              map(select(. as $v | $ex | index($v) | not))
            ')
          fi

          if [[ "$FILTERED_VERSIONS" == "[]" ]]; then
            echo "All versions already have Docker images"
            echo "build_matrix={\"include\":[]}" >> "$GITHUB_OUTPUT"
            echo "has_builds=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Get list of versions that need GitHub release (not on PyPI)
          GH_RELEASE_VERSIONS="${{ steps.auto-detect.outputs.github_release_versions }}"
          echo "GitHub release-only versions: ${GH_RELEASE_VERSIONS:-none}"

          # For manual mode without wheel_versions, we need to look them up from PyPI
          if [[ "$WHEEL_VERSIONS" == "{}" || -z "$WHEEL_VERSIONS" ]]; then
            echo "Looking up highest wheel versions from PyPI..."
            ALL_PYPI=$(curl -sS --retry 3 --retry-delay 5 \
              "https://pypi.org/pypi/vllm-cpu/json" | \
              jq -r '.releases | keys[]' 2>/dev/null || echo "")

            WHEEL_VERSIONS="{"
            FIRST=true
            for base_version in $(echo "$FILTERED_VERSIONS" | jq -r '.[]'); do
              # Find highest version matching base (including .postN)
              HIGHEST=$(echo "$ALL_PYPI" | grep -E "^${base_version}(\.post[0-9]+)?$" | sort -V | tail -1)
              if [[ -n "$HIGHEST" ]]; then
                if [[ "$FIRST" != "true" ]]; then
                  WHEEL_VERSIONS="${WHEEL_VERSIONS},"
                fi
                WHEEL_VERSIONS="${WHEEL_VERSIONS}\"${base_version}\":\"${HIGHEST}\""
                FIRST=false
                echo "  $base_version -> $HIGHEST"
              else
                # Not on PyPI - use base version (will use GitHub release)
                if [[ "$FIRST" != "true" ]]; then
                  WHEEL_VERSIONS="${WHEEL_VERSIONS},"
                fi
                WHEEL_VERSIONS="${WHEEL_VERSIONS}\"${base_version}\":\"${base_version}\""
                FIRST=false
                echo "  $base_version -> $base_version (GitHub release)"
                # Add to GH release versions list
                if [[ -n "$GH_RELEASE_VERSIONS" ]]; then
                  GH_RELEASE_VERSIONS="$GH_RELEASE_VERSIONS,$base_version"
                else
                  GH_RELEASE_VERSIONS="$base_version"
                fi
              fi
            done
            WHEEL_VERSIONS="${WHEEL_VERSIONS}}"
          fi

          echo "Wheel versions mapping: $WHEEL_VERSIONS"

          # Create a JSON object for GitHub release versions lookup
          GH_RELEASE_MAP="{"
          if [[ -n "$GH_RELEASE_VERSIONS" ]]; then
            FIRST=true
            for ver in $(echo "$GH_RELEASE_VERSIONS" | tr ',' '\n' | sort -V -u); do
              if [[ "$FIRST" != "true" ]]; then
                GH_RELEASE_MAP="${GH_RELEASE_MAP},"
              fi
              GH_RELEASE_MAP="${GH_RELEASE_MAP}\"${ver}\":true"
              FIRST=false
            done
          fi
          GH_RELEASE_MAP="${GH_RELEASE_MAP}}"
          echo "GitHub release map: $GH_RELEASE_MAP"

          # Generate matrix: version Ã— variant with wheel_version and use_github_release
          BUILD_AMD64="${{ needs.base-check.outputs.build_amd64 }}"
          BUILD_ARM64="${{ needs.base-check.outputs.build_arm64 }}"

          MATRIX=$(jq -n -c \
            --argjson versions "$FILTERED_VERSIONS" \
            --argjson variants "$VARIANTS" \
            --argjson wheel_map "$WHEEL_VERSIONS" \
            --argjson gh_release_map "$GH_RELEASE_MAP" \
            --arg build_amd64 "$BUILD_AMD64" \
            --arg build_arm64 "$BUILD_ARM64" '
            {
              include: [
                $versions[] as $ver |
                $variants[] as $var |
                {
                  version: $ver,
                  variant: $var,
                  wheel_version: ($wheel_map[$ver] // $ver),
                  use_github_release: (if $gh_release_map[$ver] then "true" else "false" end),
                  platforms: (
                    if $var == "noavx512" then
                      if $build_amd64 == "true" and $build_arm64 == "true" then "linux/amd64,linux/arm64"
                      elif $build_amd64 == "true" then "linux/amd64"
                      elif $build_arm64 == "true" then "linux/arm64"
                      else ""
                      end
                    else
                      if $build_amd64 == "true" then "linux/amd64" else "" end
                    end
                  )
                }
              ] | map(select(.platforms != ""))
            }
          ')

          MATRIX_COUNT=$(echo "$MATRIX" | jq '.include | length')

          if [[ "$MATRIX_COUNT" -eq 0 ]]; then
            echo "No builds after filtering"
            echo "build_matrix={\"include\":[]}" >> "$GITHUB_OUTPUT"
            echo "has_builds=false" >> "$GITHUB_OUTPUT"
          else
            echo "Generated $MATRIX_COUNT builds"
            echo "$MATRIX" | jq '.'
            echo "build_matrix=$MATRIX" >> "$GITHUB_OUTPUT"
            echo "has_builds=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Summary
        shell: bash
        run: |
          {
            IS_AUTO_DETECT="${{ steps.auto-detect.outputs.is_auto_detect }}"
            if [[ "$IS_AUTO_DETECT" == "true" ]]; then
              VERSIONS='${{ steps.auto-detect.outputs.new_versions }}'
              MODE="Auto-detect (PyPI vs Docker Hub)"
            else
              VERSIONS='${{ needs.base-check.outputs.new_versions }}'
              MODE="Manual"
            fi

            echo "## Docker Version Check Results"
            echo ""
            echo "| Property | Value |"
            echo "|----------|-------|"
            echo "| Mode | $MODE |"
            echo "| Versions | \`$VERSIONS\` |"
            echo "| Postfix | \`${{ steps.postfix.outputs.postfix || '(none)' }}\` |"
            echo "| Latest Version | ${{ steps.latest.outputs.version }} |"
            echo "| AMD64 | ${{ needs.base-check.outputs.build_amd64 }} |"
            echo "| ARM64 | ${{ needs.base-check.outputs.build_arm64 }} |"
            echo "| Has Builds | ${{ steps.matrix.outputs.has_builds }} |"
            echo "| Needs Latest Update | ${{ steps.latest.outputs.needs_update }} |"
            echo "| Use GitHub Release | ${{ steps.postfix.outputs.use_github_release }} |"
            echo "| Skip Docker Hub | ${{ inputs.skip_dockerhub }} |"
            echo "| Skip GHCR | ${{ inputs.skip_ghcr }} |"
            echo "| Variants | \`${{ steps.variants.outputs.matrix }}\` |"
            echo ""
            echo "### Build Matrix"
            echo ""
            echo "\`\`\`json"
            echo '${{ steps.matrix.outputs.build_matrix }}' | jq .
            echo "\`\`\`"
          } >> "$GITHUB_STEP_SUMMARY"
